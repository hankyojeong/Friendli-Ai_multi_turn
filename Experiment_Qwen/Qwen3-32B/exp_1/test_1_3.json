{
  "question": "2024년 이후 월별 장기체류 외국인수 추이는?",
  "llm_answer": "<think>\nOkay, I need to answer the user's question: \"2024년 이후 월별 장기체류 외국인수 추이는?\" which translates to \"What is the monthly trend of long-term resident foreigners after 2024?\" using the given schema and meta information.\n\nFirst, let's understand the data. The table is 1_tb_resident_foreigners with columns category, cnt, p_year, p_month. The meta_description says that \"장기체류\" includes '장기체류거소' and '장기체류등록', and there's a long_term_policy of sum. The time_order is p_year and p_month. The user is asking for the monthly count of long-term residents after 2024.\n\nSo, the plan is to filter the data where the category is either '장기체류거소' or '장기체류등록' (since those are the aliases for 장기체류), and where the year is 2024 or later. Then, sum the cnt for each month, ordered by year and month.\n\nI need to make sure that the category is matched correctly using the aliases. The meta says value_alias for 장기체류 includes both '장기체류거소' and '장기체류등록', so the WHERE clause should check for those exact values. Also, the policies mention categories_disjoint is true, so there's no overlap between the categories. \n\nThe SQL query should select p_year, p_month, and the sum of cnt. Since the user wants the trend after 2024, the condition would be p_year * 100 + p_month >= 202400. Alternatively, checking p_year >= 2024 and for months, but since the data is ordered by p_year and p_month, handling it as a combined number might be easier.\n\nAlso, the output should be ordered by p_year and p_month to show the chronological trend. The final output should have the sum of cnt for each month.\n\nLet me structure the SQL:\n\nSELECT p_year, p_month, SUM(cnt) as cnt \nFROM table \nWHERE category IN (aliases for 장기체류) \nAND (p_year > 2024 OR (p_year = 2024 AND p_month >= 1))\nGROUP BY p_year, p_month\nORDER BY p_year, p_month\n\nBut since the user says \"이후\", which is \"after 2024\", does that include 2024? In Korean, \"이후\" can mean \"after and including the specified time\", but sometimes it's exclusive. However, since the user is asking for a trend, it's likely they want data starting from the beginning of 2024. So I'll include 2024 and onwards.\n\nWait, the user's question is \"2024년 이후\" which literally is \"after 2024\", but in Korean, this can sometimes mean \"2024 and onwards\". But to be precise, I should check. If the user wants data starting from 2024, then the condition is p_year >= 2024. If they want strictly after 2024 (2025 onwards), then p_year > 2024. The original question's exact phrasing is important here. The question is \"2024년 이후 월별...\", which might mean \"monthly trend from and after 2024\". So I think including 2024 is correct. \n\nTherefore, the WHERE clause would be:\n\nUPPER(TRIM(\"category\")) IN (the aliases for 장기체류)\nAND (p_year > 2024 OR (p_year = 2024 AND p_month >= 1))\n\nBut to avoid dealing with the month part for the current year, maybe combining year and month into a single integer and comparing against 202400. For example, if p_year is 2024, p_month 05 would be 202405, which is >= 202400. So the condition could be (p_year * 100 + p_month) >= 202400. That way, it's easier.\n\nSo, the SQL would group by p_year and p_month, sum the cnt, and order by those.\n\nNow, translating this into the SQL string. The table name is \"1_tb_resident_foreigners\". The category aliases are ['장기체류거소','장기체류등록']. The columns are p_year, p_month, cnt, and category.\n\nPutting it all together, the SQL would be:\n\nSELECT\n    \"p_year\",\n    \"p_month\",\n    COALESCE(SUM(CAST(\"cnt\" AS INT)), 0) AS cnt\nFROM {Q_TBL}\nWHERE \n    UPPER(TRIM(\"category\")) IN ('장기체류거소', '장기체류등록')\n    AND (\"p_year\" * 100 + \"p_month\") >= 202400\nGROUP BY \"p_year\", \"p_month\"\nORDER BY \"p_year\", \"p_month\"\n\nThis should give the monthly totals for long-term residents from 2024 onwards. The COALESCE ensures that if a month has zero entries, it shows 0 instead of NULL. The ORDER BY ensures the trend is in chronological order.\n\nAnother consideration: the data might not have records beyond 2024, but the query should still handle that, returning what's available.\n\nNow, format this into the Python code block. The code will read the Excel file into a DataFrame, create an in-memory SQLite database, and then run the query. The output is printed as CSV without the index.\n</think>\n\n```python\nimport sqlite3\nimport pandas as pd\n\nFILE = \"1_국내체류외국인.xlsx\"\nTBL_RAW = \"1_tb_resident_foreigners\"\nQ_TBL = '\"' + TBL_RAW + '\"'\n\n# load\ndf = pd.read_excel(FILE)\n\ncon = sqlite3.connect(\":memory:\")\ndf.to_sql(TBL_RAW, con, index=False)\n\nsql = '''\nSELECT\n    \"p_year\",\n    \"p_month\",\n    COALESCE(SUM(CAST(\"cnt\" AS INT)), 0) AS cnt\nFROM {Q_TBL}\nWHERE \n    UPPER(TRIM(\"category\")) IN ('장기체류거소', '장기체류등록')\n    AND (\"p_year\" * 100 + \"p_month\") >= 202400\nGROUP BY \"p_year\", \"p_month\"\nORDER BY \"p_year\", \"p_month\"\n'''.format(Q_TBL=Q_TBL)\n\nout = pd.read_sql_query(sql, con)\nprint(out.to_csv(index=False))\n```",
  "system_prompt": "[ROLE]\n너는 \"Python+SQLite 단일 쿼리 결과 봇\"이다. payload(메타+질문)를 보고,\n**오직 하나의** 파이썬 코드블록만 출력한다. 그 코드블록은 SQLite로 **단 하나의 SQL 쿼리**를 실행하고,\n그 결과만 stdout에 출력한다. 설명/해설/추가 텍스트 금지.\n\n[PAYLOAD INPUTS]\n- file_name = 1_국내체류외국인.xlsx\n- table_name = 1_tb_resident_foreigners\n- description = 국내 체류 외국인: 단기체류/장기체류거소/장기체류등록 월별 집계\n- meta_description =\n\nschema:\n  category: str\n  cnt: int\n  p_year: int\n  p_month: int\nvalue_alias:\n  장기체류: ['장기체류거소','장기체류등록']\n  등록외국인: ['장기체류등록']\n  외국국적동포_거소신고: ['장기체류거소']\npolicies:\n  categories_disjoint: true\n  long_term_policy: sum\n  time_order: ['p_year','p_month']\n\n- user_question = 2024년 이후 월별 장기체류 외국인수 추이는?\n\n[HARD OUTPUT RULES]\n1) 출력은 정확히 하나의 코드블록: 시작 ```python, 끝 ``` . 코드블록 밖에는 아무것도 출력하지 말 것.\n2) 코드 첫 두 줄은 반드시:\n   import sqlite3\n   import pandas as pd\n3) 파일 저장/자기 재실행/네트워크 호출 금지. stdout만 사용.\n4) 최종 출력은 print(out.to_csv(index=False)) 또는 print(out.to_string(index=False)).\n\n[PRELUDE (필수 코드 헤더)]\n- 변수명 고정:\n  FILE = \"<file_name 그대로>\"\n  TBL_RAW = \"<table_name 그대로>\"\n  Q_TBL   = '\"' + TBL_RAW + '\"'\n- 파일 적재:\n  if FILE.lower().endswith(\".xlsx\"): df = pd.read_excel(FILE)\n  else: df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n- con = sqlite3.connect(\":memory:\")\n- df.to_sql(TBL_RAW, con, index=False)\n\n[SQL 문자열 형식]\n- f-string 금지. 아래 형식만 사용:\n  sql = '''\n<완성된 실제 SQL>\n'''.format(Q_TBL=Q_TBL)\n- 테이블 참조는 항상 FROM {Q_TBL} (또는 FROM {{Q_TBL}} 허용).\n- 식별자는 이중따옴표로 인용: \"category\",\"p_year\",\"p_month\",\"cnt\",\"base_ym\",\"sido\",\"sigungu\",\"age\",\"table_nm\",\"upjong\",\"gbn\".\n- DataFrame.query 금지. 모든 필터/집계는 SQL에서 수행.\n- 결과는 질문 의도에 맞는 **최소 열**만 포함하고, 명시적 ORDER BY 포함.\n\n[정규화/안전 규칙]\n- 합계는 항상 NULL 세이프:\n  COALESCE(SUM(CAST(\"cnt\" AS INT)), 0) AS cnt\n- 문자열 비교는 UPPER(TRIM(...)):\n  UPPER(TRIM(\"category\")), UPPER(TRIM(\"sido\")), UPPER(TRIM(\"sigungu\")), TRIM(\"base_ym\")\n- 지역 강건 매칭 예:\n  (UPPER(TRIM(\"sido\")) IN ('경기','경기도') OR UPPER(TRIM(\"sido\")) LIKE '경기%')\n  (UPPER(TRIM(\"sigungu\")) IN ('화성','화성시') OR UPPER(TRIM(\"sigungu\")) LIKE '화성%')\n- base_ym 정규화(YYYYMM):\n  REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"),'-',''),'_',''),'.','')\n- 월 두 자리 고정: 4월 → '04' 같은 상수로 직접 기입.\n- 카테고리 별칭(있다면 meta_description.category.alias로 확장):\n  \"장기체류\" → ['장기체류거소','장기체류등록'] 등.\n\n[분기→월 전개(선언된 경우만)]\n- meta_description.quarter_policy가 base_is_quarterly=true면, quarter_map을 사용해 월로 전개:\n  repeat_each_month 또는 use_last_month_of_quarter 정책을 따름.\n\n[의도 처리(일반 규칙)]\n- 질문에서 필요한 상수(연/월/연속 구간/지역/카테고리)를 추출해 **SQL 상수로 직접 기입**.\n- \"특정 시점 단일 값\"은 WHERE로 걸러 행이 없어지지 않게, **조건부 집계**로 한 행을 강제.\n- \"월별/연도별 추이\"는 GROUP BY + ORDER BY.\n- \"분포\"는 차원 열(age 등) + 합계.\n\n[EXAMPLE — 완전히 일반적인 절차만 시연(실제 데이터와 무관)]\n사용자 질문(예): \"2021년 1~3월, 국가=KOREA의 월별 매출 합계?\"\n가상의 스키마(예): [\"order_date\"(YYYY-MM-DD), \"country\", \"amount\"]\n\n```python\nimport sqlite3\nimport pandas as pd\n\nFILE = \"orders.csv\"\nTBL_RAW = \"orders\"\nQ_TBL = '\"' + TBL_RAW + '\"'\n\n# load\nif FILE.lower().endswith(\".xlsx\"):\n    df = pd.read_excel(FILE)\nelse:\n    df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n\ncon = sqlite3.connect(\":memory:\")\ndf.to_sql(TBL_RAW, con, index=False)\n\n# SQL: 월(YYYY-MM) 추출 → 2021-01~03, 국가=KOREA, 월별 합계\nsql = '''\nWITH X AS (\n  SELECT\n    SUBSTR(TRIM(\"order_date\"),1,7) AS ym,\n    UPPER(TRIM(\"country\")) AS cty,\n    CAST(\"amount\" AS REAL) AS amt\n  FROM {Q_TBL}\n)\nSELECT\n  CAST(SUBSTR(ym,1,4) AS INT) AS year,\n  CAST(SUBSTR(ym,6,2) AS INT) AS month,\n  COALESCE(SUM(amt),0) AS total_amount\nFROM X\nWHERE ym BETWEEN '2021-01' AND '2021-03'\n  AND cty = 'KOREA'\nGROUP BY CAST(SUBSTR(ym,1,4) AS INT), CAST(SUBSTR(ym,6,2) AS INT)\nORDER BY year, month\n'''.format(Q_TBL=Q_TBL)\n\nout = pd.read_sql_query(sql, con)\nprint(out.to_csv(index=False))\n",
  "_runtime": {
    "py_path": "C:\\Users\\hanky\\OneDrive\\Desktop\\서울대학교\\IDEA 연구실\\LLM\\Friendli AI\\Experiment_Qwen\\Qwen3-32B\\exp_1\\test_1_3.py",
    "stdout": "p_year,p_month,cnt\r\n2024,1,1893911\r\n2024,2,1891853\r\n2024,3,1912870\r\n2024,4,1933874\r\n2024,5,1953619\r\n2024,6,1966820\r\n2024,7,1982246\r\n2024,8,1986270\r\n2024,9,2009960\r\n2024,10,2033177\r\n2024,11,2042013\r\n2024,12,2042017\r\n2025,1,2042236"
  },
  "_payload_var": "payload_1_3"
}