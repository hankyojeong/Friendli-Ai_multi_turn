{
  "question": "2023~2025년 3년간 1월 장기체류 외국인 수와 전년 대비 증감률은?",
  "llm_answer": "<think>\nOkay, I need to solve this user's question: \"2023~2025년 3년간 1월 장기체류 외국인 수와 전년 대비 증감률은?\" which translates to asking for the number of long-term foreign residents in South Korea for each January from 2023 to 2025, along with the year-over-year growth rate.\n\nFirst, let me understand the data structure. The user provided an Excel file (1_국내체류외국인.xlsx) which is loaded into the SQLite table 1_tb_resident_foreigners. The schema includes category, p_year, p_month, and cnt. The category has aliases: '장기체류' includes '장기체류거소' and '장기체류등록'. The user wants data for January of each year from 2023 to 2025. But wait, 2025 hasn't happened yet, so maybe the data only goes up to 2024. But the user might still want the query to include 2025 as a placeholder, assuming the data might be available or to show that there's no data for 2025.\n\nNext, I need to aggregate the count (cnt) for each January (p_month=1) where the category is either '장기체류거소' or '장기체류등록'. The aliases in the meta_description say that '장기체류' includes both, so I should filter category in those two values.\n\nThe challenge is calculating the year-over-year growth rate. To do this, I need to compare each year's January count with the previous year's. For example, 2023 vs. 2024, and 2024 vs. 2025. But since we're dealing with SQL, I can use window functions. Specifically, use the LAG() function to get the previous year's count and compute the percentage change.\n\nThe steps I need to follow in the SQL query:\n\n1. Filter the data to include only the '장기체류' categories and months January (p_month=1) for the years 2023, 2024, and 2025.\n2. Sum the cnt for each year and month, ensuring that if there's no data for a certain January, it's treated as zero using COALESCE.\n3. Use a window function to get the previous year's count (LAG) to calculate the difference and then the growth rate.\n4. Format the output to show the year, count, and growth rate (as a percentage) from the previous year.\n\nWait, but the user's data might not have 2025 data yet. So if I include p_year up to 2025, but there's no data, the count would be zero, and the growth rate from 2024 would be (0 - 2024_count)/2024_count. That's a possible negative percentage, but that's correct based on data availability.\n\nNow, structuring the SQL:\n\n- Use a Common Table Expression (CTE) to aggregate the counts by year and month.\n- Then, in the final query, calculate the previous year's count and the growth rate.\n\nLet me outline the SQL steps:\n\n1. Create a CTE named 'annual_counts' that groups by year and month=1, sums the cnt, and orders by year.\n2. In the main query, select each year's data along with the previous year's count (using LAG).\n3. Calculate the difference and the growth rate as ((current - previous) / previous) * 100.\n4. Filter the final results to only the years 2023 to 2025, but since the LAG requires a previous year, maybe start from 2024.\n\nWait, but 2023 is the start. For 2023, there's no previous year in the dataset, so the growth rate for 2023 would be null or zero. The user probably wants to see the growth rate from 2023 to 2024, and from 2024 to 2025. So in the final output, we can have rows for 2023, 2024, 2025, and the growth rate for 2024 is compared to 2023, and for 2025 to 2024.\n\nBut in SQL, when using LAG, the first year (2023) will have a NULL for the previous year's count. To handle that, perhaps in the final output, we can filter out the first year's growth rate if it's NULL, or include it as blank.\n\nBut the user's question is about the three years (2023-2025) and the growth rates between them. So the output should have columns: year, count, growth_rate (compared to previous year). For 2023, the growth rate would be NULL (no previous year), 2024 would have 2023's count, 2025 would have 2024's count.\n\nNow, translating this into SQL:\n\nFirst, in the CTE, filter for category in 장기체류, and p_month=1, and p_year between 2023 and 2025. Then sum the cnt.\n\nIn the main query, use LAG to get the previous year's count, then calculate the difference and growth rate.\n\nBut how to handle if the previous year's count is zero? However, the user's data might not have zero counts, so we can assume that if a year is missing, the count is zero. Wait, no. The data is for actual months, but in the case of 2025, if there's no data, the count is zero.\n\nBut the query uses COALESCE(SUM, 0) so even if there are no entries for a certain year and month, it will show zero. So the CTE will have entries for 2023, 2024, 2025, each with their January counts.\n\nTherefore, in the main query, when using LAG, we can calculate the growth rate even if the previous year's count is zero (but division by zero is an issue. However, in SQL, dividing by zero will result in NULL or an error. To handle that, need to add a CASE statement to avoid division by zero. However, the data for the previous year is likely to exist, except for 2023 if the data starts from 2023, but since we are including p_year from 2023 onwards, the previous year for 2024 is 2023, and for 2025 is 2024. Assuming the data includes 2023 and 2024 (but not 2025), but the user is asking for 2023~2025, so the query should include all three.\n\nSo, in the code, I'll proceed with the following SQL:\n\nWITH cte AS (\n  SELECT\n    p_year,\n    SUM(COALESCE(cnt, 0)) AS cnt\n  FROM \"1_tb_resident_foreigners\"\n  WHERE UPPER(TRIM(category)) IN ('장기체류거소', '장기체류등록')\n    AND p_month = 1\n    AND p_year BETWEEN 2023 AND 2025\n  GROUP BY p_year\n  ORDER BY p_year\n)\nSELECT\n  p_year,\n  cnt,\n  LAG(cnt, 1) OVER (ORDER BY p_year) AS prev_cnt,\n  (cnt - LAG(cnt, 1) OVER (ORDER BY p_year)) / NULLIF(LAG(cnt, 1) OVER (ORDER BY p_year), 0) * 100 AS growth_rate\nFROM cte\nORDER BY p_year;\n\nBut in the final output, we need to ensure that p_year is within 2023 to 2025, and the growth rate is calculated from the previous year. But how to handle the 2023 case where there is no previous year? The LAG will return NULL, so the growth rate would be (current - NULL)/NULL, which is NULL. The user might want to display that as N/A or just not show it. However, the problem says to output the count and the growth rate for each of the three years, so maybe we need to include all three, even if the growth rate for 2023 is NULL.\n\nAlternatively, perhaps the user is interested in the growth from year to year, so the main rows would be 2024 (growth from 2023) and 2025 (growth from 2024). But the question asks for each January's count and the growth rate compared to the previous year. So for 2023, there is no previous year, so growth rate is NULL. For 2024 and 2025, growth rate is calculated.\n\nNow, putting this all together into the Python code. The code needs to load the data, create a CTE to aggregate the counts for the relevant years and month, then compute the growth rate using window functions.\n\nI need to make sure that the SQL uses the correct table name, which is \"1_tb_resident_foreigners\", with the \"category\" in the specified values. Also, p_month is 1 for January, and p_year is between 2023 and 2025.\n\nAlso, ensure that the category is checked against the aliases: 장기체류 includes 장기체류거소 and 장기체류등록. The code should use UPPER(TRIM(category)) to normalize the category names.\n\nTesting the query with the given constraints, I think the code should be as outlined.\n</think>\n\n```python\nimport sqlite3\nimport pandas as pd\n\nFILE = \"1_국내체류외국인.xlsx\"\nTBL_RAW = \"1_tb_resident_foreigners\"\nQ_TBL = '\"' + TBL_RAW + '\"'\n\n# load\nif FILE.lower().endswith(\".xlsx\"):\n    df = pd.read_excel(FILE)\nelse:\n    df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n\ncon = sqlite3.connect(\":memory:\")\ndf.to_sql(TBL_RAW, con, index=False)\n\n# SQL: 연도 별 1월 장기체류자 수 및 전년 대비 증감률\nsql = '''\nWITH YearlyCounts AS (\n  SELECT\n    CAST(\"p_year\" AS INT) AS year,\n    COALESCE(SUM(CAST(\"cnt\" AS INT)), 0) AS cnt\n  FROM {Q_TBL}\n  WHERE UPPER(TRIM(\"category\")) IN ('장기체류거소', '장기체류등록')\n    AND CAST(\"p_month\" AS INT) = 1\n    AND CAST(\"p_year\" AS INT) BETWEEN 2023 AND 2025\n  GROUP BY CAST(\"p_year\" AS INT)\n  ORDER BY CAST(\"p_year\" AS INT)\n)\nSELECT\n  year,\n  cnt,\n  ROUND(100.0 * (cnt - LAG(cnt, 1) OVER (ORDER BY year))/NULLIF(LAG(cnt, 1) OVER (ORDER BY year), 0), 2) AS growth_rate\nFROM YearlyCounts\nORDER BY year\n'''.format(Q_TBL=Q_TBL)\n\nout = pd.read_sql_query(sql, con)\nprint(out.to_csv(index=False))\n```",
  "system_prompt": "[ROLE]\n너는 \"Python+SQLite 단일 쿼리 결과 봇\"이다. payload(메타+질문)를 보고,\n**오직 하나의** 파이썬 코드블록만 출력한다. 그 코드블록은 SQLite로 **단 하나의 SQL 쿼리**를 실행하고,\n그 결과만 stdout에 출력한다. 설명/해설/추가 텍스트 금지.\n\n[PAYLOAD INPUTS]\n- file_name = 1_국내체류외국인.xlsx\n- table_name = 1_tb_resident_foreigners\n- description = 국내 체류 외국인: 단기체류/장기체류거소/장기체류등록 월별 집계\n- meta_description =\n\nschema:\n  category: str\n  cnt: int\n  p_year: int\n  p_month: int\nvalue_alias:\n  장기체류: ['장기체류거소','장기체류등록']\n  등록외국인: ['장기체류등록']\n  외국국적동포_거소신고: ['장기체류거소']\npolicies:\n  categories_disjoint: true\n  long_term_policy: sum\n  time_order: ['p_year','p_month']\n\n- user_question = 2023~2025년 3년간 1월 장기체류 외국인 수와 전년 대비 증감률은?\n\n[HARD OUTPUT RULES]\n1) 출력은 정확히 하나의 코드블록: 시작 ```python, 끝 ``` . 코드블록 밖에는 아무것도 출력하지 말 것.\n2) 코드 첫 두 줄은 반드시:\n   import sqlite3\n   import pandas as pd\n3) 파일 저장/자기 재실행/네트워크 호출 금지. stdout만 사용.\n4) 최종 출력은 print(out.to_csv(index=False)) 또는 print(out.to_string(index=False)).\n\n[PRELUDE (필수 코드 헤더)]\n- 변수명 고정:\n  FILE = \"<file_name 그대로>\"\n  TBL_RAW = \"<table_name 그대로>\"\n  Q_TBL   = '\"' + TBL_RAW + '\"'\n- 파일 적재:\n  if FILE.lower().endswith(\".xlsx\"): df = pd.read_excel(FILE)\n  else: df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n- con = sqlite3.connect(\":memory:\")\n- df.to_sql(TBL_RAW, con, index=False)\n\n[SQL 문자열 형식]\n- f-string 금지. 아래 형식만 사용:\n  sql = '''\n<완성된 실제 SQL>\n'''.format(Q_TBL=Q_TBL)\n- 테이블 참조는 항상 FROM {Q_TBL} (또는 FROM {{Q_TBL}} 허용).\n- 식별자는 이중따옴표로 인용: \"category\",\"p_year\",\"p_month\",\"cnt\",\"base_ym\",\"sido\",\"sigungu\",\"age\",\"table_nm\",\"upjong\",\"gbn\".\n- DataFrame.query 금지. 모든 필터/집계는 SQL에서 수행.\n- 결과는 질문 의도에 맞는 **최소 열**만 포함하고, 명시적 ORDER BY 포함.\n\n[정규화/안전 규칙]\n- 합계는 항상 NULL 세이프:\n  COALESCE(SUM(CAST(\"cnt\" AS INT)), 0) AS cnt\n- 문자열 비교는 UPPER(TRIM(...)):\n  UPPER(TRIM(\"category\")), UPPER(TRIM(\"sido\")), UPPER(TRIM(\"sigungu\")), TRIM(\"base_ym\")\n- 지역 강건 매칭 예:\n  (UPPER(TRIM(\"sido\")) IN ('경기','경기도') OR UPPER(TRIM(\"sido\")) LIKE '경기%')\n  (UPPER(TRIM(\"sigungu\")) IN ('화성','화성시') OR UPPER(TRIM(\"sigungu\")) LIKE '화성%')\n- base_ym 정규화(YYYYMM):\n  REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"),'-',''),'_',''),'.','')\n- 월 두 자리 고정: 4월 → '04' 같은 상수로 직접 기입.\n- 카테고리 별칭(있다면 meta_description.category.alias로 확장):\n  \"장기체류\" → ['장기체류거소','장기체류등록'] 등.\n\n[분기→월 전개(선언된 경우만)]\n- meta_description.quarter_policy가 base_is_quarterly=true면, quarter_map을 사용해 월로 전개:\n  repeat_each_month 또는 use_last_month_of_quarter 정책을 따름.\n\n[의도 처리(일반 규칙)]\n- 질문에서 필요한 상수(연/월/연속 구간/지역/카테고리)를 추출해 **SQL 상수로 직접 기입**.\n- \"특정 시점 단일 값\"은 WHERE로 걸러 행이 없어지지 않게, **조건부 집계**로 한 행을 강제.\n- \"월별/연도별 추이\"는 GROUP BY + ORDER BY.\n- \"분포\"는 차원 열(age 등) + 합계.\n\n[EXAMPLE — 완전히 일반적인 절차만 시연(실제 데이터와 무관)]\n사용자 질문(예): \"2021년 1~3월, 국가=KOREA의 월별 매출 합계?\"\n가상의 스키마(예): [\"order_date\"(YYYY-MM-DD), \"country\", \"amount\"]\n\n```python\nimport sqlite3\nimport pandas as pd\n\nFILE = \"orders.csv\"\nTBL_RAW = \"orders\"\nQ_TBL = '\"' + TBL_RAW + '\"'\n\n# load\nif FILE.lower().endswith(\".xlsx\"):\n    df = pd.read_excel(FILE)\nelse:\n    df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n\ncon = sqlite3.connect(\":memory:\")\ndf.to_sql(TBL_RAW, con, index=False)\n\n# SQL: 월(YYYY-MM) 추출 → 2021-01~03, 국가=KOREA, 월별 합계\nsql = '''\nWITH X AS (\n  SELECT\n    SUBSTR(TRIM(\"order_date\"),1,7) AS ym,\n    UPPER(TRIM(\"country\")) AS cty,\n    CAST(\"amount\" AS REAL) AS amt\n  FROM {Q_TBL}\n)\nSELECT\n  CAST(SUBSTR(ym,1,4) AS INT) AS year,\n  CAST(SUBSTR(ym,6,2) AS INT) AS month,\n  COALESCE(SUM(amt),0) AS total_amount\nFROM X\nWHERE ym BETWEEN '2021-01' AND '2021-03'\n  AND cty = 'KOREA'\nGROUP BY CAST(SUBSTR(ym,1,4) AS INT), CAST(SUBSTR(ym,6,2) AS INT)\nORDER BY year, month\n'''.format(Q_TBL=Q_TBL)\n\nout = pd.read_sql_query(sql, con)\nprint(out.to_csv(index=False))\n",
  "_runtime": {
    "py_path": "C:\\Users\\hanky\\OneDrive\\Desktop\\서울대학교\\IDEA 연구실\\LLM\\Friendli AI\\Experiment_Qwen\\Qwen3-32B\\exp_1\\test_1_6.py",
    "stdout": "year,cnt,growth_rate\r\n2023,1694876,\r\n2024,1893911,11.74\r\n2025,2042236,7.83"
  },
  "_payload_var": "payload_1_6"
}