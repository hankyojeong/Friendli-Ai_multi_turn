{
  "question": "(E-9)국내 외국인 근로자의 월별 추이는?",
  "llm_answer": "<think>\nOkay, let's see. The user is asking about the monthly trend of foreign workers in Korea, specifically under the E-9 category. The data comes from the '3_외국인근로자.xlsx' file, and the table is named '3_tb_foreign_workers_permit'. The columns available are base_ym, sido, upjong, cnt.\n\nFirst, I need to extract the monthly data. The base_ym is probably in a format that can be parsed into year and month. Since the user wants a monthly trend, I should group by year and month.\n\nWait, the base_ym might be stored as a string, maybe in YYYY-MM format or something similar. So I'll need to process it. The example showed using SUBSTR to extract parts of the date. Let's use SUBSTR to get the year and month. Also, since base_ym might have varying formats (like with dashes or periods), I should normalize it by removing non-numeric characters.\n\nThe example used TRIM and REPLACE to clean the base_ym. So maybe first, I'll process base_ym to make sure it's in YYYYMM format. Wait, but the example for monthly trends used 'YYYY-MM' format. Hmm. Maybe the original data's base_ym is in a format that can be converted into a proper year-month.\n\nSo the plan is: extract the year and month from base_ym, normalize it, then group by that to get the count each month. Sum the cnt per month, order by the year-month.\n\nWait, the cnt is the number of permits per quarter? Because the description says it's quarterly data. Oh, the user is asking for monthly trend, but the data might be stored in a quarterly basis. So the data might have entries for Q1, Q2, etc. Wait, but the table's name mentions \"분기\" which is quarter. So the original data is quarterly. But the user wants monthly trend. So how to handle that.\n\nThe master rules mention that if meta_description.quarter_policy is set, we use quarter_map to expand into months. But in the user's input, the meta_description doesn't include that. The user's payload has meta_description as an empty string. So maybe the data is stored with base_ym as quarterly periods. So for example, 2023-Q1. But the user wants monthly data. Hmm, but how to convert quarterly data into monthly. Since there's no information on how the data is distributed in the quarter, the example rules mention using either repeat_each_month or use_last_month_of_quarter. But without knowing the policy, maybe the data is stored as the last month of the quarter. For example, Q1 is represented as 2023-03. So perhaps we can process the base_ym to find the month part.\n\nWait, the original data might have base_ym in a monthly format. Maybe the description is a mistake. Or maybe the data is stored as yearly and quarter, but the user wants to see monthly trend. Since the user's data's file name is 3_외국인근로자.xlsx and the table is quarterly, perhaps the base_ym is the quarter's end month. For example, 2023-Q1 is represented as 2023-03. So when extracting, we can take the month part.\n\nWait, the columns are base_ym, sido, upjong, cnt. If base_ym is in quarters, perhaps it's stored as 2023Q1, 2023Q2, etc. But the example in the hard rules uses YYYYMM format. Hmm. Maybe the base_ym is in a format that can be converted to a month. For example, if it's stored as 202303, then year is first 4 digits, month next two. If it's in a different format, maybe with dashes or slashes, we need to process it.\n\nBut the user's input doesn't mention that the data is quarterly. Wait, the user's question is about (E-9) foreign workers' monthly trend, but the table is for quarterly distribution. So there's a need to convert quarterly data into monthly. However, the master rules under [분기→월 전개(선언된 경우만)] say that if meta_description.quarter_policy is true, then use quarter_map. Since in the user's input, the meta_description is empty, maybe there's no such policy. Therefore, the data is stored as monthly, but the description mentions quarterly distribution. Hmm, this is a bit conflicting.\n\nAlternatively, maybe the base_ym is stored in a monthly format, and the description mentions that the data is provided quarterly. In any case, the user is asking for monthly trend, so we need to extract year and month from base_ym, sum the cnt per month, and order by year-month.\n\nSo steps:\n\n1. Clean base_ym by trimming and removing non-digit characters, then split into year and month. For example, if base_ym is 2023Q1, then normalizing would not help. So maybe the actual data's base_ym is in a format like 202303 (YYYYMM). Let's assume that after processing, base_ym is in YYYYMM. If not, this code may fail, but according to the example, that's how it's handled.\n\n2. Extract year and month from base_ym. For each row, create a year and month column.\n\n3. Sum the cnt for each year-month.\n\n4. Order the results by year and month.\n\nSo the SQL would be something like:\n\nSELECT \n  CAST(SUBSTR(...) AS INT) AS year, \n  CAST(...) AS month, \n  SUM(cnt) AS total \nFROM ... \nGROUP BY year, month \nORDER BY year, month.\n\nChecking the hard rules, the example uses SUBSTR on the date field. So I'll use SUBSTR on base_ym after normalizing it.\n\nThe code would:\n\n- Process base_ym by TRIM and replaces to remove non-digit characters.\n\nWait, the safe rules mention base_ym normalization using REPLACE for -, _, . etc. So the code would:\n\nREPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', '') as normalized_base_ym.\n\nThen extract year and month from it. If normalized_base_ym is '202303', then year is SUBSTR(normalized_base_ym, 1, 4), month is 5,6.\n\nSo the SQL would have a CTE to normalize base_ym and split into year and month.\n\nThe example uses COALESCE(SUM(CAST(... AS INT)),0) as cnt. So in the SQL, sum the cnt, cast to integer, handle nulls.\n\nAlso, the result should be ordered by year then month.\n\nSo putting it all together.\n\nThe code would create a CTE X where base_ym is normalized, then split into year and month. Then group by and order by.\n\nNow, writing the SQL:\n\nWITH X AS (\n  SELECT \n    TRIM(\"base_ym\") AS base_ym, \n    ...\n)\nBut according to safe rules, base_ym is normalized using REPLACEs.\n\nWait, the safe rules specify:\n\nbase_ym 정규화(YYYYMM):\nREPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"),'-',''),'_',''),'.','')\n\nThen, perhaps, in the SQL:\n\nSELECT \n  REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', '') AS normalized_yyyymm,\n  ...\nFROM ...\n\nThen, extract year and month from normalized_yyyymm:\n\nSUBSTR(normalized_yyyymm, 1, 4) AS year_str, \nSUBSTR(normalized_yyyymm, 5, 2) AS month_str.\n\nThen cast them to integers.\n\nSo the final SQL would be:\n\nWITH X AS (\n  SELECT \n    REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', '') AS normalized_yyyymm,\n    \"cnt\"\n  FROM {Q_TBL}\n)\nSELECT \n  CAST(SUBSTR(normalized_yyyymm, 1, 4) AS INT) AS year,\n  CAST(SUBSTR(normalized_yyyymm, 5, 2) AS INT) AS month,\n  COALESCE(SUM(CAST(\"cnt\" AS INT)), 0) AS cnt\nFROM X\nGROUP BY normalized_yyyymm\nORDER BY year, month\n\nWait, group by normalized_yyyymm ensures that even if there are multiple entries per month (unlikely here), it's summed. Then, since normalized_yyyymm is ordered, the ORDER BY would correctly sort.\n\nBut to make sure, the group by is on the normalized_yyyymm, but the group by in SQL must be on the columns used in the select. Alternatively, group by year and month.\n\nBut for correctness, in the SQL standards, when using aggregate functions, all columns in the select that are not aggregated must be in the group by. So in SQLite, if you have:\n\nSELECT a, b, SUM(c) ... GROUP BY a, b.\n\nSo in our case, if we do group by normalized_yyyymm, then the year and month are derived from that, so it's okay.\n\nBut to avoid issues, maybe group by the year and month as integers. But since normalized_yyyymm is a string, but in the select, year and month are derived from it, grouping by normalized_yyyymm should be equivalent to grouping by year and month.\n\nBut perhaps better to group by the substrings. Let's see.\n\nAlternative approach:\n\nGROUP BY CAST(SUBSTR(...) AS INT), CAST(...) AS INT.\n\nBut to avoid issues with the GROUP BY and avoid using the same expressions in multiple places, using the CTE to compute the year and month might be better.\n\nAlternatively, in the CTE, compute the year and month as integers.\n\nBut given that the code needs to be in a single SQL query, and the example shows using substr, perhaps the code would proceed as follows.\n\nSo, final SQL would be:\n\nWITH X AS (\n  SELECT \n    CAST(SUBSTR(REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', ''), 1, 4) AS INT) AS year,\n    CAST(SUBSTR(REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', ''), 5, 2) AS INT) AS month,\n    CAST(\"cnt\" AS INT) AS cnt\n  FROM {Q_TBL}\n)\nSELECT \n  year, \n  month, \n  SUM(cnt) AS cnt\nFROM X\nGROUP BY year, month\nORDER BY year, month\n\nBut wait, what if the cnt is stored as a string? Then casting to INT would be necessary.\n\nYes, in the final select, COALESCE(SUM(...), 0) is used. But in the X CTE, we can safely cast cnt to integer.\n\nSo putting it all together, the SQL would be:\n\nWITH X AS (\n  SELECT \n    CAST(SUBSTR(REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', ''), 1, 4) AS INT) AS year,\n    CAST(SUBSTR(REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', ''), 5, 2) AS INT) AS month,\n    CAST(\"cnt\" AS INT) AS cnt\n  FROM {Q_TBL}\n)\nSELECT \n  year, \n  month, \n  COALESCE(SUM(cnt), 0) AS cnt\nFROM X\nGROUP BY year, month\nORDER BY year, month\n\nBut in the SQL string, the replacement for Q_TBL is needed. So the code would format {Q_TBL} as the table name.\n\nSo the final code in the Python block would be:\n\nimport sqlite3\nimport pandas as pd\n\nFILE = \"3_외국인근로자.xlsx\"\nTBL_RAW = \"3_tb_foreign_workers_permit\"\nQ_TBL = '\"' + TBL_RAW + '\"'\n\nif FILE.lower().endswith(\".xlsx\"):\n    df = pd.read_excel(FILE)\nelse:\n    df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n\ncon = sqlite3.connect(\":memory:\")\ndf.to_sql(TBL_RAW, con, index=False)\n\nsql = '''\nWITH X AS (\n  SELECT \n    CAST(SUBSTR(REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', ''), 1, 4) AS INT) AS \"year\",\n    CAST(SUBSTR(REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', ''), 5, 2) AS INT) AS \"month\",\n    CAST(\"cnt\" AS INT) AS \"cnt\"\n  FROM {Q_TBL}\n)\nSELECT \n  \"year\",\n  \"month\",\n  COALESCE(SUM(\"cnt\"), 0) AS \"cnt\"\nFROM X\nGROUP BY \"year\", \"month\"\nORDER BY \"year\", \"month\"\n'''.format(Q_TBL=Q_TBL)\n\nout = pd.read_sql_query(sql, con)\nprint(out.to_csv(index=False))\n\nWait, but in the SQL, the column names are enclosed in double quotes. However, in the CTE, the column names are year, month, cnt. So in the final SELECT, grouping by those.\n\nBut also, the SQL uses \"year\", \"month\", etc., to ensure that the group by is done correctly.\n\nThis should work. The code reads the Excel file, loads into SQLite, processes the base_ym to year and month, sums the cnt per month, and orders by year and month.\n\nI think this would answer the user's question about the monthly trend.\n</think>\n\n```python\nimport sqlite3\nimport pandas as pd\n\nFILE = \"3_외국인근로자.xlsx\"\nTBL_RAW = \"3_tb_foreign_workers_permit\"\nQ_TBL = '\"' + TBL_RAW + '\"'\n\nif FILE.lower().endswith(\".xlsx\"):\n    df = pd.read_excel(FILE)\nelse:\n    df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n\ncon = sqlite3.connect(\":memory:\")\ndf.to_sql(TBL_RAW, con, index=False)\n\nsql = '''\nWITH X AS (\n  SELECT \n    CAST(SUBSTR(REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', ''), 1, 4) AS INT) AS \"year\",\n    CAST(SUBSTR(REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', ''), 5, 2) AS INT) AS \"month\",\n    COALESCE(CAST(\"cnt\" AS INT), 0) AS \"cnt\"\n  FROM {Q_TBL}\n)\nSELECT \n  \"year\",\n  \"month\",\n  SUM(\"cnt\") AS \"cnt\"\nFROM X\nGROUP BY \"year\", \"month\"\nORDER BY \"year\", \"month\"\n'''.format(Q_TBL=Q_TBL)\n\nout = pd.read_sql_query(sql, con)\nprint(out.to_csv(index=False))\n```",
  "system_prompt": "[ROLE]\n너는 \"Python+SQLite 단일 쿼리 결과 봇\"이다. payload(메타+질문)를 보고,\n**오직 하나의** 파이썬 코드블록만 출력한다. 그 코드블록은 SQLite로 **단 하나의 SQL 쿼리**를 실행하고,\n그 결과만 stdout에 출력한다. 설명/해설/추가 텍스트 금지.\n\n[PAYLOAD INPUTS]\n- file_name = 3_외국인근로자.xlsx\n- table_name = 3_tb_foreign_workers_permit\n- description = 비전문취업(E-9) 외국인 근로자 업종/지역 분포(분기)\n- meta_description =\n- base_ym, sido, upjong, cnt\n- user_question = (E-9)국내 외국인 근로자의 월별 추이는?\n\n[HARD OUTPUT RULES]\n1) 출력은 정확히 하나의 코드블록: 시작 ```python, 끝 ``` . 코드블록 밖에는 아무것도 출력하지 말 것.\n2) 코드 첫 두 줄은 반드시:\n   import sqlite3\n   import pandas as pd\n3) 파일 저장/자기 재실행/네트워크 호출 금지. stdout만 사용.\n4) 최종 출력은 print(out.to_csv(index=False)) 또는 print(out.to_string(index=False)).\n\n[PRELUDE (필수 코드 헤더)]\n- 변수명 고정:\n  FILE = \"<file_name 그대로>\"\n  TBL_RAW = \"<table_name 그대로>\"\n  Q_TBL   = '\"' + TBL_RAW + '\"'\n- 파일 적재:\n  if FILE.lower().endswith(\".xlsx\"): df = pd.read_excel(FILE)\n  else: df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n- con = sqlite3.connect(\":memory:\")\n- df.to_sql(TBL_RAW, con, index=False)\n\n[SQL 문자열 형식]\n- f-string 금지. 아래 형식만 사용:\n  sql = '''\n<완성된 실제 SQL>\n'''.format(Q_TBL=Q_TBL)\n- 테이블 참조는 항상 FROM {Q_TBL} (또는 FROM {{Q_TBL}} 허용).\n- 식별자는 이중따옴표로 인용: \"category\",\"p_year\",\"p_month\",\"cnt\",\"base_ym\",\"sido\",\"sigungu\",\"age\",\"table_nm\",\"upjong\",\"gbn\".\n- DataFrame.query 금지. 모든 필터/집계는 SQL에서 수행.\n- 결과는 질문 의도에 맞는 **최소 열**만 포함하고, 명시적 ORDER BY 포함.\n\n[정규화/안전 규칙]\n- 합계는 항상 NULL 세이프:\n  COALESCE(SUM(CAST(\"cnt\" AS INT)), 0) AS cnt\n- 문자열 비교는 UPPER(TRIM(...)):\n  UPPER(TRIM(\"category\")), UPPER(TRIM(\"sido\")), UPPER(TRIM(\"sigungu\")), TRIM(\"base_ym\")\n- 지역 강건 매칭 예:\n  (UPPER(TRIM(\"sido\")) IN ('경기','경기도') OR UPPER(TRIM(\"sido\")) LIKE '경기%')\n  (UPPER(TRIM(\"sigungu\")) IN ('화성','화성시') OR UPPER(TRIM(\"sigungu\")) LIKE '화성%')\n- base_ym 정규화(YYYYMM):\n  REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"),'-',''),'_',''),'.','')\n- 월 두 자리 고정: 4월 → '04' 같은 상수로 직접 기입.\n- 카테고리 별칭(있다면 meta_description.category.alias로 확장):\n  \"장기체류\" → ['장기체류거소','장기체류등록'] 등.\n\n[분기→월 전개(선언된 경우만)]\n- meta_description.quarter_policy가 base_is_quarterly=true면, quarter_map을 사용해 월로 전개:\n  repeat_each_month 또는 use_last_month_of_quarter 정책을 따름.\n\n[의도 처리(일반 규칙)]\n- 질문에서 필요한 상수(연/월/연속 구간/지역/카테고리)를 추출해 **SQL 상수로 직접 기입**.\n- \"특정 시점 단일 값\"은 WHERE로 걸러 행이 없어지지 않게, **조건부 집계**로 한 행을 강제.\n- \"월별/연도별 추이\"는 GROUP BY + ORDER BY.\n- \"분포\"는 차원 열(age 등) + 합계.\n\n[EXAMPLE — 완전히 일반적인 절차만 시연(실제 데이터와 무관)]\n사용자 질문(예): \"2021년 1~3월, 국가=KOREA의 월별 매출 합계?\"\n가상의 스키마(예): [\"order_date\"(YYYY-MM-DD), \"country\", \"amount\"]\n\n```python\nimport sqlite3\nimport pandas as pd\n\nFILE = \"orders.csv\"\nTBL_RAW = \"orders\"\nQ_TBL = '\"' + TBL_RAW + '\"'\n\n# load\nif FILE.lower().endswith(\".xlsx\"):\n    df = pd.read_excel(FILE)\nelse:\n    df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n\ncon = sqlite3.connect(\":memory:\")\ndf.to_sql(TBL_RAW, con, index=False)\n\n# SQL: 월(YYYY-MM) 추출 → 2021-01~03, 국가=KOREA, 월별 합계\nsql = '''\nWITH X AS (\n  SELECT\n    SUBSTR(TRIM(\"order_date\"),1,7) AS ym,\n    UPPER(TRIM(\"country\")) AS cty,\n    CAST(\"amount\" AS REAL) AS amt\n  FROM {Q_TBL}\n)\nSELECT\n  CAST(SUBSTR(ym,1,4) AS INT) AS year,\n  CAST(SUBSTR(ym,6,2) AS INT) AS month,\n  COALESCE(SUM(amt),0) AS total_amount\nFROM X\nWHERE ym BETWEEN '2021-01' AND '2021-03'\n  AND cty = 'KOREA'\nGROUP BY CAST(SUBSTR(ym,1,4) AS INT), CAST(SUBSTR(ym,6,2) AS INT)\nORDER BY year, month\n'''.format(Q_TBL=Q_TBL)\n\nout = pd.read_sql_query(sql, con)\nprint(out.to_csv(index=False))\n",
  "_runtime": {
    "py_path": "C:\\Users\\hanky\\OneDrive\\Desktop\\서울대학교\\IDEA 연구실\\LLM\\Friendli AI\\Experiment_Qwen\\Qwen3-32B\\exp_1\\test_3_1.py",
    "stdout": "year,month,cnt\r\n2022,3,161921\r\n2022,6,163886\r\n2022,9,181247\r\n2022,12,203121\r\n2023,3,211361\r\n2023,6,225307\r\n2023,9,237846\r\n2023,12,247191\r\n2024,3,260047\r\n2024,6,260073\r\n2024,9,267452\r\n2024,12,271925\r\n2025,3,273139"
  },
  "_payload_var": "payload_3_1"
}