{
  "question": "2023년 7월 기준 국내 단기 체류 외국인 수는?",
  "llm_answer": "<think>\nOkay, let's tackle this user question: \"2023년 7월 기준 국내 단기 체류 외국인 수는?\" which translates to \"What is the number of short-term foreign residents in South Korea as of July 2023?\" \n\nFirst, I need to understand the data structure. The schema provided includes category, cnt, p_year, and p_month. The categories are '단기체류', '장기체류거소', and '장기체류등록'. The user is asking specifically about '단기체류', so I need to filter the category to that exact value.\n\nThe user mentioned July 2023, so I need to set the conditions where p_year is 2023 and p_month is 7. Since the data might be stored with those columns as strings, I should cast them to integers to ensure accurate comparison. Also, the cnt should be summed, but since it's already the count, maybe it's just selecting the cnt where the category and date match.\n\nWait, the schema says cnt is the number of people. So if there's a row for 2023-07 with category '단기체류', then cnt would be the number we need. So the SQL should select cnt where category is '단기체류', p_year=2023, p_month=7. But need to make sure that the category is exactly '단기체류' and not any of the others. Also, check if there's any possible case sensitivity, but the meta_description says to use UPPER(TRIM(...)), so maybe the SQL should standardize the category.\n\nLooking at the value_alias, '장기체류' includes both '장기체류거소' and '장기체류등록', but the user is asking for '단기체류', which is separate. So no need to sum anything here. Just filter category to '단기체류'.\n\nThe SQL should select the cnt where category is '단기체류', p_year=2023, and p_month=7. Also, since the user wants the count, if there's no data for that month, it should return 0. So using COALESCE to handle possible NULLs.\n\nPutting it all together: SELECT COALESCE(SUM(cnt), 0) AS cnt FROM table WHERE category is '단기체류', p_year=2023, p_month=7. But need to make sure that the category is correctly matched, using UPPER and TRIM as per the rules. Also, the columns are in quotes.\n\nSo the SQL would be something like:\n\nSELECT COALESCE(SUM(CAST(\"cnt\" AS INT)), 0) AS cnt\nFROM \"1_tb_resident_foreigners\"\nWHERE UPPER(TRIM(\"category\")) = '단기체류'\n  AND CAST(\"p_year\" AS INT) = 2023\n  AND CAST(\"p_month\" AS INT) = 7;\n\nBut since the policies say that categories are disjoint, maybe the SUM is unnecessary if there's only one row. However, to be safe, using SUM and COALESCE ensures that even if there are multiple rows (though they shouldn't be, given the schema), it sums them and defaults to 0 if none.\n\nAlso, the output should be a single row with the count. The code should then print that value. The Python code would execute this SQL and output the result as a CSV or string without the index.\n</think>\n\n```python\nimport sqlite3\nimport pandas as pd\n\nFILE = \"1_국내체류외국인.xlsx\"\nTBL_RAW = \"1_tb_resident_foreigners\"\nQ_TBL = '\"' + TBL_RAW + '\"'\n\nif FILE.lower().endswith(\".xlsx\"):\n    df = pd.read_excel(FILE)\nelse:\n    df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n\ncon = sqlite3.connect(\":memory:\")\ndf.to_sql(TBL_RAW, con, index=False)\n\nsql = '''\nSELECT COALESCE(SUM(CAST(\"cnt\" AS INT)), 0) AS cnt\nFROM {Q_TBL}\nWHERE UPPER(TRIM(\"category\")) = '단기체류'\n  AND CAST(\"p_year\" AS INT) = 2023\n  AND CAST(\"p_month\" AS INT) = 7\n'''.format(Q_TBL=Q_TBL)\n\nout = pd.read_sql_query(sql, con)\nprint(out.to_string(index=False))\n```",
  "system_prompt": "[ROLE]\n너는 \"Python+SQLite 단일 쿼리 결과 봇\"이다. payload(메타+질문)를 보고,\n**오직 하나의** 파이썬 코드블록만 출력한다. 그 코드블록은 SQLite로 **단 하나의 SQL 쿼리**를 실행하고,\n그 결과만 stdout에 출력한다. 설명/해설/추가 텍스트 금지.\n\n[PAYLOAD INPUTS]\n- file_name = 1_국내체류외국인.xlsx\n- table_name = 1_tb_resident_foreigners\n- description = 국내 체류하고 있는 외국인을 단기체류, 등록외국인, 외국국적동포_거소신고의 3개 카테고리로 구분하고, 각 카테고리별 외국인 수를 월별로 집계한 데이터\n- meta_description =\n\nschema:\n  category: str   # {'단기체류','장기체류거소','장기체류등록'}\n  cnt: int        # 인원수\n  p_year: int     # 예: 2022, 2023, 2024, 2025\n  p_month: int    # 1~12\n\nvalue_alias:\n  # 질문/사용자 표현을 실제 값으로 정규화\n  장기체류: ['장기체류거소','장기체류등록']   # 합산 대상으로 해석\n  등록외국인: ['장기체류등록']\n  외국국적동포_거소신고: ['장기체류거소']\n\npolicies:\n  categories_disjoint: true        # 서로 겹치지 않음 → 합산 안전\n  long_term_policy: sum            # alias가 다수이면 SUM으로 집계\n  time_order: ['p_year','p_month'] # 시계열 정렬 기준\n\nnotes:\n  - 숫자/특수문자로 시작하는 식별자는 SQLite에서 \"...\"로 인용\n  - dtype 강제: cnt,p_year,p_month는 숫자형으로 캐스팅 후 사용\n\n- user_question = 2023년 7월 기준 국내 단기 체류 외국인 수는?\n\n[HARD OUTPUT RULES]\n1) 출력은 정확히 하나의 코드블록: 시작 ```python, 끝 ``` . 코드블록 밖에는 아무것도 출력하지 말 것.\n2) 코드 첫 두 줄은 반드시:\n   import sqlite3\n   import pandas as pd\n3) 파일 저장/자기 재실행/네트워크 호출 금지. stdout만 사용.\n4) 최종 출력은 print(out.to_csv(index=False)) 또는 print(out.to_string(index=False)).\n\n[PRELUDE (필수 코드 헤더)]\n- 변수명 고정:\n  FILE = \"<file_name 그대로>\"\n  TBL_RAW = \"<table_name 그대로>\"\n  Q_TBL   = '\"' + TBL_RAW + '\"'\n- 파일 적재:\n  if FILE.lower().endswith(\".xlsx\"): df = pd.read_excel(FILE)\n  else: df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n- con = sqlite3.connect(\":memory:\")\n- df.to_sql(TBL_RAW, con, index=False)\n\n[SQL 문자열 형식]\n- f-string 금지. 아래 형식만 사용:\n  sql = '''\n<완성된 실제 SQL>\n'''.format(Q_TBL=Q_TBL)\n- 테이블 참조는 항상 FROM {Q_TBL} (또는 FROM {{Q_TBL}} 허용).\n- 식별자는 이중따옴표로 인용: \"category\",\"p_year\",\"p_month\",\"cnt\",\"base_ym\",\"sido\",\"sigungu\",\"age\",\"table_nm\",\"upjong\",\"gbn\".\n- DataFrame.query 금지. 모든 필터/집계는 SQL에서 수행.\n- 결과는 질문 의도에 맞는 **최소 열**만 포함하고, 명시적 ORDER BY 포함.\n\n[정규화/안전 규칙]\n- 합계는 항상 NULL 세이프:\n  COALESCE(SUM(CAST(\"cnt\" AS INT)), 0) AS cnt\n- 문자열 비교는 UPPER(TRIM(...)):\n  UPPER(TRIM(\"category\")), UPPER(TRIM(\"sido\")), UPPER(TRIM(\"sigungu\")), TRIM(\"base_ym\")\n- 지역 강건 매칭 예:\n  (UPPER(TRIM(\"sido\")) IN ('경기','경기도') OR UPPER(TRIM(\"sido\")) LIKE '경기%')\n  (UPPER(TRIM(\"sigungu\")) IN ('화성','화성시') OR UPPER(TRIM(\"sigungu\")) LIKE '화성%')\n- base_ym 정규화(YYYYMM):\n  REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"),'-',''),'_',''),'.','')\n- 월 두 자리 고정: 4월 → '04' 같은 상수로 직접 기입.\n- 카테고리, 지역 등 별칭이 meta_description.value_alias로 정의된 경우 해당 목록을 모두 비교에 사용.\n\n[분기→월 전개(선언된 경우만)]\n- meta_description에서 base_is_quarterly=true인 경우, quarter_map과 quarter_policy에 따라 월 데이터로 전개.\n  - repeat_each_month: 분기 값을 각 월에 복제.\n  - use_last_month_of_quarter: 분기 마지막 달에만 값 배치.\n\n[의도 처리(일반 규칙)]\n- 질문에서 필요한 상수(연/월/연속 구간/지역/카테고리)를 추출해 **SQL 상수로 직접 기입**.\n- \"YYYY~YYYY\" 또는 \"YYYYMM~YYYYMM\" 범위는 BETWEEN으로 변환한다.\n- \"특정 시점 단일 값\"은 WHERE로 걸러 행이 없어지지 않게 **조건부 집계**로 한 행을 강제.\n- \"월별/연도별 추이\"는 GROUP BY + ORDER BY.\n- \"분포\"는 차원 열(age 등) + 합계.\n- \"전년 대비 증감률\"은 `(현재-이전)/NULLIF(이전,0)*100`으로 계산하여 별도 열로 출력.\n- 범위·월/연도 상수를 추출할 때는 숫자를 두 자리 월(예: 4월→'04')로 표준화한다.\n\n[EXAMPLE — 완전히 일반적인 절차만 시연(실제 데이터와 무관)]\n사용자 질문(예): \"2021년 1~3월, 국가=KOREA의 월별 매출 합계?\"\n가상의 스키마(예): [\"order_date\"(YYYY-MM-DD), \"country\", \"amount\"]\n\n```python\nimport sqlite3\nimport pandas as pd\n\nFILE = \"orders.csv\"\nTBL_RAW = \"orders\"\nQ_TBL = '\"' + TBL_RAW + '\"'\n\n# load\nif FILE.lower().endswith(\".xlsx\"):\n    df = pd.read_excel(FILE)\nelse:\n    df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n\ncon = sqlite3.connect(\":memory:\")\ndf.to_sql(TBL_RAW, con, index=False)\n\n# SQL: 월(YYYY-MM) 추출 → 2021-01~03, 국가=KOREA, 월별 합계\nsql = '''\nWITH X AS (\n  SELECT\n    SUBSTR(TRIM(\"order_date\"),1,7) AS ym,\n    UPPER(TRIM(\"country\")) AS cty,\n    CAST(\"amount\" AS REAL) AS amt\n  FROM {Q_TBL}\n)\nSELECT\n  CAST(SUBSTR(ym,1,4) AS INT) AS year,\n  CAST(SUBSTR(ym,6,2) AS INT) AS month,\n  COALESCE(SUM(amt),0) AS total_amount\nFROM X\nWHERE ym BETWEEN '2021-01' AND '2021-03'\n  AND cty = 'KOREA'\nGROUP BY CAST(SUBSTR(ym,1,4) AS INT), CAST(SUBSTR(ym,6,2) AS INT)\nORDER BY year, month\n'''.format(Q_TBL=Q_TBL)\n\nout = pd.read_sql_query(sql, con)\nprint(out.to_csv(index=False))\n",
  "_runtime": {
    "py_path": "C:\\Users\\hanky\\OneDrive\\Desktop\\서울대학교\\IDEA 연구실\\LLM\\Friendli AI\\Experiment_Qwen\\Qwen3-32B\\exp_2\\test_1_2.py",
    "stdout": "cnt\n652095"
  },
  "_payload_var": "payload_1_2"
}