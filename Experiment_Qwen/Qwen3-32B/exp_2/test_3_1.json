{
  "question": "(E-9)국내 외국인 근로자의 월별 추이는?",
  "llm_answer": "<think>\nOkay, let's tackle this user question: \"(E-9)국내 외국인 근로자의 월별 추이는?\" which translates to \"What is the monthly trend of foreign workers with E-9 visas in South Korea?\" \n\nFirst, I need to understand the data structure. The user provided a file named 3_외국인근로자.xlsx with a table 3_tb_foreign_workers_permit. The description mentions it's quarterly data for E-9 visa holders, categorized by industry and region, and they want the monthly trend.\n\nThe metadata includes base_ym (year-month as a string), sido (region), upjong (industry), and cnt (count of foreigners). The base_is_quarterly is true, and the quarter_policy is repeat_each_month. The quarter_map defines which months belong to each quarter.\n\nSince the data is stored quarterly but the user wants monthly trends, I need to expand the quarterly data into monthly data. The quarter_policy is repeat_each_month, which means each quarter's value should be repeated for each month in that quarter. For example, Q1 (months 01, 02, 03) would have the same count for each month.\n\nSo the steps are:\n\n1. Extract the year and quarter from base_ym. Since base_ym is a string, I'll process it to get the year and quarter. For example, '202301' becomes year 2023 and Q1.\n\n2. Use the quarter_map to generate all months in the quarter. For each row, create three months (for each quarter) and repeat the cnt value for each month.\n\n3. Group by year and month to sum the counts, ensuring that each month's data is aggregated correctly.\n\n4. Order the results by year and month to show the trend over time.\n\nI need to handle the base_ym correctly. The user's data might have base_ym in formats like '2023-01' or '202301', so using REPLACE to remove non-numeric characters to get 'YYYYMM' format.\n\nAlso, since the data is quarterly, I need to split the quarter into its constituent months. For example, if the quarter is 1Q, generate '01', '02', '03' as months.\n\nThe SQL query should first process the base_ym to extract year and quarter, then cross join with the months in that quarter, then aggregate.\n\nWait, but SQLite doesn't have a GENERATE_SERIES function, so I need another way to split the quarter into months. The quarter_map defines which months are in each quarter. So for each row, I can generate three rows (for each month in the quarter) and assign the cnt to each.\n\nBut how to do that in SQL? Maybe using a CASE statement or a UNION ALL for each month in the quarter. Alternatively, create a helper table with the quarter and months, but since we're using in-memory SQLite, maybe a CTE with the quarter months.\n\nAlternatively, since the quarter_map is fixed, I can hardcode the months for each quarter in the query. For example, if the quarter is 1Q, then months are '01', '02', '03', and so on.\n\nSo the approach would be:\n\n- For each row in the original data, generate three rows (one for each month in the quarter), repeating the cnt value for each month.\n\nThen, group by year and month to sum the counts.\n\nSo the SQL would look something like:\n\nWITH expanded AS (\n  SELECT \n    SUBSTR(REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', ''), 1, 4) AS year,\n    CASE \n      WHEN quarter = '1Q' THEN '01'\n      WHEN quarter = '2Q' THEN '04'\n      WHEN quarter = '3Q' THEN '07'\n      WHEN quarter = '4Q' THEN '10'\n    END AS start_month,\n    CASE \n      WHEN quarter = '1Q' THEN '03'\n      WHEN quarter = '2Q' THEN '06'\n      WHEN quarter = '3Q' THEN '09'\n      WHEN quarter = '4Q' THEN '12'\n    END AS end_month,\n    \"cnt\"\n  FROM ... \n)\n-- Then generate each month in the quarter and repeat the cnt\n-- But how to generate each month? Maybe using a recursive CTE or a numbers table.\n\nAlternatively, since the quarter is known, we can split into months using a series of UNION ALLs. For example, for each quarter, create three rows for each month in the quarter.\n\nBut that might get complicated. Another approach is to map the quarter to the list of months and then cross join with a virtual table that contains the months for that quarter.\n\nWait, maybe using a lateral join or a subquery that generates the months for the quarter. But SQLite doesn't support LATERAL. Hmm.\n\nAlternatively, in the CTE, for each row, create three rows with the respective months. For example, if the quarter is 1Q, then generate three rows with months 01, 02, 03. This can be done using a UNION ALL for each month in the quarter.\n\nBut how to determine which months belong to which quarter? The quarter_map in the metadata defines that. So in the SQL, for each row, we can check the quarter and then generate the corresponding months.\n\nSo the SQL could be structured as:\n\nWITH quarterly_data AS (\n  SELECT \n    REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', '') AS base_ym,\n    \"cnt\"\n  FROM {Q_TBL}\n),\nexpanded AS (\n  SELECT \n    base_ym,\n    cnt,\n    month\n  FROM quarterly_data\n  JOIN (\n    SELECT '1Q' AS quarter, '01' AS month UNION ALL\n    SELECT '1Q', '02' UNION ALL\n    SELECT '1Q', '03' UNION ALL\n    SELECT '2Q', '04' UNION ALL\n    SELECT '2Q', '05' UNION ALL\n    SELECT '2Q', '06' UNION ALL\n    SELECT '3Q', '07' UNION ALL\n    SELECT '3Q', '08' UNION ALL\n    SELECT '3Q', '09' UNION ALL\n    SELECT '4Q', '10' UNION ALL\n    SELECT '4Q', '11' UNION ALL\n    SELECT '4Q', '12'\n  ) AS months\n  ON CASE \n    WHEN SUBSTR(base_ym, 5, 2) IN ('01', '02', '03') THEN '1Q'\n    WHEN SUBSTR(base_ym, 5, 2) IN ('04', '05', '06') THEN '2Q'\n    WHEN SUBSTR(base_ym, 5, 2) IN ('07', '08', '09') THEN '3Q'\n    ELSE '4Q'\n  END = months.quarter\n)\nSELECT \n  SUBSTR(base_ym, 1, 4) AS year,\n  month AS month,\n  SUM(cnt) AS cnt\nFROM expanded\nGROUP BY year, month\nORDER BY year, month;\n\nWait, but the original data is stored as quarterly, so the base_ym in the original table is the quarter's base_ym. For example, if the data is for Q1 2023, the base_ym might be '202301' (assuming it's stored as the first month of the quarter). But according to the quarter_policy, which is repeat_each_month, we need to repeat the value for each month in the quarter.\n\nSo the approach is to take each quarterly entry and create three entries for each month in the quarter, each with the same cnt. Then, when grouping by year and month, we can sum them up.\n\nBut how to map the quarter to the months? The quarter_map defines which months are in each quarter. So for each row in the original data, we need to determine which quarter it belongs to, then generate the three months in that quarter.\n\nFor example, if the original data has base_ym as '202301', that's Q1. So we generate three rows: 202301, 202302, 202303, each with the same cnt.\n\nBut how to do that in SQL? The way to do this is to create a mapping of quarters to months, then for each row, join with the corresponding months.\n\nIn the SQL, I can create a CTE that maps quarters to their months, then join that with the original data based on the quarter.\n\nSo the steps in SQL would be:\n\n1. Process the base_ym to extract the year and quarter.\n\n2. Join with a mapping table that has each quarter and its corresponding months.\n\n3. For each row, create three rows (one for each month in the quarter).\n\n4. Then group by year and month to sum the cnt.\n\nBut how to create the mapping table? Since the quarter_map is fixed, I can hardcode it in the SQL using a series of UNION ALLs.\n\nSo the mapping would be:\n\nSELECT '1Q' AS quarter, '01' AS month UNION ALL\nSELECT '1Q', '02' UNION ALL\nSELECT '1Q', '03' UNION ALL\nSELECT '2Q', '04' UNION ALL\n... and so on for all quarters and months.\n\nThen, for each row in the original data, determine the quarter (based on the month part of base_ym), and join with the mapping to get the months in that quarter.\n\nSo the SQL would look like:\n\nWITH quarterly_data AS (\n  SELECT \n    REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', '') AS base_ym,\n    \"cnt\"\n  FROM {Q_TBL}\n),\nquarter_to_months AS (\n  SELECT '1Q' AS quarter, '01' AS month UNION ALL\n  SELECT '1Q', '02' UNION ALL\n  SELECT '1Q', '03' UNION ALL\n  SELECT '2Q', '04' UNION ALL\n  SELECT '2Q', '05' UNION ALL\n  SELECT '2Q', '06' UNION ALL\n  SELECT '3Q', '07' UNION ALL\n  SELECT '3Q', '08' UNION ALL\n  SELECT '3Q', '09' UNION ALL\n  SELECT '4Q', '10' UNION ALL\n  SELECT '4Q', '11' UNION ALL\n  SELECT '4Q', '12'\n),\nexpanded_data AS (\n  SELECT \n    q.base_ym,\n    q.cnt,\n    m.month\n  FROM quarterly_data q\n  JOIN quarter_to_months m\n  ON CASE \n    WHEN SUBSTR(q.base_ym, 5, 2) IN ('01', '02', '03') THEN '1Q'\n    WHEN SUBSTR(q.base_ym, 5, 2) IN ('04', '05', '06') THEN '2Q'\n    WHEN SUBSTR(q.base_ym, 5, 2) IN ('07', '08', '09') THEN '3Q'\n    ELSE '4Q'\n  END = m.quarter\n)\nSELECT \n  SUBSTR(base_ym, 1, 4) AS year,\n  m.month AS month,\n  SUM(cnt) AS cnt\nFROM expanded_data\nGROUP BY year, month\nORDER BY year, month;\n\nThis should generate the monthly data by expanding each quarter into its three months and repeating the cnt for each month. Then, grouping by year and month to sum the counts.\n\nBut wait, the original data might have multiple entries for the same quarter. For example, if there are multiple rows for Q1 2023, each would be expanded into three months. The SUM(cnt) would aggregate all those entries for each month.\n\nThis should give the monthly trend as required.\n\nNow, translating this into the Python code with the correct SQL query.\n\nThe code should load the data, create the in-memory SQLite database, then execute the SQL query as described.\n\nThe final output should be a DataFrame with columns year, month, cnt, ordered by year and month.\n\nI need to make sure that the SQL is correctly formatted with the {Q_TBL} placeholder replaced, and that all string comparisons are done with UPPER and TRIM, but in this case, since we're dealing with base_ym, which is already processed, maybe not necessary. However, the base_ym might have leading/trailing spaces or different separators, so using TRIM and replacing non-numeric characters is important.\n\nAlso, the cnt is cast to INT using COALESCE(SUM(CAST(...)), 0) to handle NULLs.\n\nPutting it all together, the SQL query should be as above, with the correct formatting.\n</think>\n\n```python\nimport sqlite3\nimport pandas as pd\n\nFILE = \"3_외국인근로자.xlsx\"\nTBL_RAW = \"3_tb_foreign_workers_permit\"\nQ_TBL = '\"' + TBL_RAW + '\"'\n\n# load\nif FILE.lower().endswith(\".xlsx\"):\n    df = pd.read_excel(FILE)\nelse:\n    df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n\ncon = sqlite3.connect(\":memory:\")\ndf.to_sql(TBL_RAW, con, index=False)\n\n# SQL: 분기→월 전개 후 월별 집계\nsql = '''\nWITH quarterly_data AS (\n  SELECT \n    REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"), '-', ''), '_', ''), '.', '') AS base_ym,\n    CAST(\"cnt\" AS INT) AS cnt\n  FROM {Q_TBL}\n),\nquarter_to_months AS (\n  SELECT '1Q' AS quarter, '01' AS month UNION ALL\n  SELECT '1Q', '02' UNION ALL\n  SELECT '1Q', '03' UNION ALL\n  SELECT '2Q', '04' UNION ALL\n  SELECT '2Q', '05' UNION ALL\n  SELECT '2Q', '06' UNION ALL\n  SELECT '3Q', '07' UNION ALL\n  SELECT '3Q', '08' UNION ALL\n  SELECT '3Q', '09' UNION ALL\n  SELECT '4Q', '10' UNION ALL\n  SELECT '4Q', '11' UNION ALL\n  SELECT '4Q', '12'\n),\nexpanded_data AS (\n  SELECT \n    q.base_ym,\n    q.cnt,\n    m.month\n  FROM quarterly_data q\n  JOIN quarter_to_months m\n  ON CASE \n    WHEN SUBSTR(q.base_ym, 5, 2) IN ('01','02','03') THEN '1Q'\n    WHEN SUBSTR(q.base_ym, 5, 2) IN ('04','05','06') THEN '2Q'\n    WHEN SUBSTR(q.base_ym, 5, 2) IN ('07','08','09') THEN '3Q'\n    ELSE '4Q'\n  END = m.quarter\n)\nSELECT \n  CAST(SUBSTR(base_ym, 1, 4) AS INT) AS year,\n  CAST(month AS INT) AS month,\n  COALESCE(SUM(cnt), 0) AS cnt\nFROM expanded_data\nGROUP BY SUBSTR(base_ym, 1, 4), month\nORDER BY year, month\n'''.format(Q_TBL=Q_TBL)\n\nout = pd.read_sql_query(sql, con)\nprint(out.to_csv(index=False))\n```",
  "system_prompt": "[ROLE]\n너는 \"Python+SQLite 단일 쿼리 결과 봇\"이다. payload(메타+질문)를 보고,\n**오직 하나의** 파이썬 코드블록만 출력한다. 그 코드블록은 SQLite로 **단 하나의 SQL 쿼리**를 실행하고,\n그 결과만 stdout에 출력한다. 설명/해설/추가 텍스트 금지.\n\n[PAYLOAD INPUTS]\n- file_name = 3_외국인근로자.xlsx\n- table_name = 3_tb_foreign_workers_permit\n- description = 비전문취업(E-9) 비자를 가진 외국인 근로자의 업종/지역별 분포를 분기별로 집계한 데이터\n- meta_description =\n\n- base_ym: 기준년월 (문자형)\n- sido: 시도 (문자형)\n- upjong: 업종 (문자형)\n- cnt: 외국인 수 (정수형)\n\nbase_is_quarterly: true\nquarter_policy: repeat_each_month\nquarter_map:\n  1Q: ['01','02','03']\n  2Q: ['04','05','06']\n  3Q: ['07','08','09']\n  4Q: ['10','11','12']\n\n- user_question = (E-9)국내 외국인 근로자의 월별 추이는?\n\n[HARD OUTPUT RULES]\n1) 출력은 정확히 하나의 코드블록: 시작 ```python, 끝 ``` . 코드블록 밖에는 아무것도 출력하지 말 것.\n2) 코드 첫 두 줄은 반드시:\n   import sqlite3\n   import pandas as pd\n3) 파일 저장/자기 재실행/네트워크 호출 금지. stdout만 사용.\n4) 최종 출력은 print(out.to_csv(index=False)) 또는 print(out.to_string(index=False)).\n\n[PRELUDE (필수 코드 헤더)]\n- 변수명 고정:\n  FILE = \"<file_name 그대로>\"\n  TBL_RAW = \"<table_name 그대로>\"\n  Q_TBL   = '\"' + TBL_RAW + '\"'\n- 파일 적재:\n  if FILE.lower().endswith(\".xlsx\"): df = pd.read_excel(FILE)\n  else: df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n- con = sqlite3.connect(\":memory:\")\n- df.to_sql(TBL_RAW, con, index=False)\n\n[SQL 문자열 형식]\n- f-string 금지. 아래 형식만 사용:\n  sql = '''\n<완성된 실제 SQL>\n'''.format(Q_TBL=Q_TBL)\n- 테이블 참조는 항상 FROM {Q_TBL} (또는 FROM {{Q_TBL}} 허용).\n- 식별자는 이중따옴표로 인용: \"category\",\"p_year\",\"p_month\",\"cnt\",\"base_ym\",\"sido\",\"sigungu\",\"age\",\"table_nm\",\"upjong\",\"gbn\".\n- DataFrame.query 금지. 모든 필터/집계는 SQL에서 수행.\n- 결과는 질문 의도에 맞는 **최소 열**만 포함하고, 명시적 ORDER BY 포함.\n\n[정규화/안전 규칙]\n- 합계는 항상 NULL 세이프:\n  COALESCE(SUM(CAST(\"cnt\" AS INT)), 0) AS cnt\n- 문자열 비교는 UPPER(TRIM(...)):\n  UPPER(TRIM(\"category\")), UPPER(TRIM(\"sido\")), UPPER(TRIM(\"sigungu\")), TRIM(\"base_ym\")\n- 지역 강건 매칭 예:\n  (UPPER(TRIM(\"sido\")) IN ('경기','경기도') OR UPPER(TRIM(\"sido\")) LIKE '경기%')\n  (UPPER(TRIM(\"sigungu\")) IN ('화성','화성시') OR UPPER(TRIM(\"sigungu\")) LIKE '화성%')\n- base_ym 정규화(YYYYMM):\n  REPLACE(REPLACE(REPLACE(TRIM(\"base_ym\"),'-',''),'_',''),'.','')\n- 월 두 자리 고정: 4월 → '04' 같은 상수로 직접 기입.\n- 카테고리, 지역 등 별칭이 meta_description.value_alias로 정의된 경우 해당 목록을 모두 비교에 사용.\n\n[분기→월 전개(선언된 경우만)]\n- meta_description에서 base_is_quarterly=true인 경우, quarter_map과 quarter_policy에 따라 월 데이터로 전개.\n  - repeat_each_month: 분기 값을 각 월에 복제.\n  - use_last_month_of_quarter: 분기 마지막 달에만 값 배치.\n\n[의도 처리(일반 규칙)]\n- 질문에서 필요한 상수(연/월/연속 구간/지역/카테고리)를 추출해 **SQL 상수로 직접 기입**.\n- \"YYYY~YYYY\" 또는 \"YYYYMM~YYYYMM\" 범위는 BETWEEN으로 변환한다.\n- \"특정 시점 단일 값\"은 WHERE로 걸러 행이 없어지지 않게 **조건부 집계**로 한 행을 강제.\n- \"월별/연도별 추이\"는 GROUP BY + ORDER BY.\n- \"분포\"는 차원 열(age 등) + 합계.\n- \"전년 대비 증감률\"은 `(현재-이전)/NULLIF(이전,0)*100`으로 계산하여 별도 열로 출력.\n- 범위·월/연도 상수를 추출할 때는 숫자를 두 자리 월(예: 4월→'04')로 표준화한다.\n\n[EXAMPLE — 완전히 일반적인 절차만 시연(실제 데이터와 무관)]\n사용자 질문(예): \"2021년 1~3월, 국가=KOREA의 월별 매출 합계?\"\n가상의 스키마(예): [\"order_date\"(YYYY-MM-DD), \"country\", \"amount\"]\n\n```python\nimport sqlite3\nimport pandas as pd\n\nFILE = \"orders.csv\"\nTBL_RAW = \"orders\"\nQ_TBL = '\"' + TBL_RAW + '\"'\n\n# load\nif FILE.lower().endswith(\".xlsx\"):\n    df = pd.read_excel(FILE)\nelse:\n    df = pd.read_csv(FILE, encoding=\"utf-8-sig\", low_memory=False)\n\ncon = sqlite3.connect(\":memory:\")\ndf.to_sql(TBL_RAW, con, index=False)\n\n# SQL: 월(YYYY-MM) 추출 → 2021-01~03, 국가=KOREA, 월별 합계\nsql = '''\nWITH X AS (\n  SELECT\n    SUBSTR(TRIM(\"order_date\"),1,7) AS ym,\n    UPPER(TRIM(\"country\")) AS cty,\n    CAST(\"amount\" AS REAL) AS amt\n  FROM {Q_TBL}\n)\nSELECT\n  CAST(SUBSTR(ym,1,4) AS INT) AS year,\n  CAST(SUBSTR(ym,6,2) AS INT) AS month,\n  COALESCE(SUM(amt),0) AS total_amount\nFROM X\nWHERE ym BETWEEN '2021-01' AND '2021-03'\n  AND cty = 'KOREA'\nGROUP BY CAST(SUBSTR(ym,1,4) AS INT), CAST(SUBSTR(ym,6,2) AS INT)\nORDER BY year, month\n'''.format(Q_TBL=Q_TBL)\n\nout = pd.read_sql_query(sql, con)\nprint(out.to_csv(index=False))\n",
  "_runtime": {
    "py_path": "C:\\Users\\hanky\\OneDrive\\Desktop\\서울대학교\\IDEA 연구실\\LLM\\Friendli AI\\Experiment_Qwen\\Qwen3-32B\\exp_2\\test_3_1.py",
    "stdout": "year,month,cnt\r\n2022,1,161921\r\n2022,2,161921\r\n2022,3,161921\r\n2022,4,163886\r\n2022,5,163886\r\n2022,6,163886\r\n2022,7,181247\r\n2022,8,181247\r\n2022,9,181247\r\n2022,10,203121\r\n2022,11,203121\r\n2022,12,203121\r\n2023,1,211361\r\n2023,2,211361\r\n2023,3,211361\r\n2023,4,225307\r\n2023,5,225307\r\n2023,6,225307\r\n2023,7,237846\r\n2023,8,237846\r\n2023,9,237846\r\n2023,10,247191\r\n2023,11,247191\r\n2023,12,247191\r\n2024,1,260047\r\n2024,2,260047\r\n2024,3,260047\r\n2024,4,260073\r\n2024,5,260073\r\n2024,6,260073\r\n2024,7,267452\r\n2024,8,267452\r\n2024,9,267452\r\n2024,10,271925\r\n2024,11,271925\r\n2024,12,271925\r\n2025,1,273139\r\n2025,2,273139\r\n2025,3,273139"
  },
  "_payload_var": "payload_3_1"
}